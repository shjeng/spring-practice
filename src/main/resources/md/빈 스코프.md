### 빈 스코프란?
지금까지 우리는 스프링 빈이 스프링 컨테이너의 시작과 함께 생성되어서 스프링 컨테이너가 종료될 때 까지 유지된다고 학습했다.
이것은 스프링 빈이 기본적으로 싱글톤 스코프로 생성되기 때문이다. 스코프는 번역 그대로 빈이 존재할 수 있는 범위를 뜻한다. 

><strong>스프링은 다음과 같은 다양한 스코프를 지원한다. </strong>
* 싱글톤: 가장 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다. 
* 프로토타입: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다. 
* 웹 관련 스코프
  * reqeust: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프이다. 
  * session: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프이다. 
  * application: 웹의 서블릿 컨텍스와 같은 범위로 유지되는 스코프이다.
  
<hr>

### 프로토타입 스코프
1. 프로토타입 스코프의 빈을 스프링 컨테이너에 요청
2. 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하고, 필요한 의존관계를 주입한다. 
3. 스프링 컨에니터는 생성한 프로토타입 빈을 클라이언트에 반환한다.
4. 이후에 스프링 컨테이너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환한다.

<strong>프로토 타입 빈의 특징 정리</strong>
* 스프링 컨테이너에 요청할 때 마다 새로 생성
* 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여
* 종료 메서드가 호출되지 않는다.
* 그래서 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 함. 종료 메서드에 대한 호출도 클라이언트가 직접 해야한다.

<hr>

### 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점

* 테스트 코드를 확인! (싱글톤 빈과 프로토타입 빈의 생명주기가 같으면 안됨!!)

<hr>

### 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 문제 해결
* 직접 필요한 의존관계를 찾는 것을 Dependency Lookup(DL) 의존관계 조회(탐색) 이라한다. 
* ObjectFactory: 기능이 단순, 별도의 라이브러리 필요 없음, 스프링에 의존 
* ObjectProvider: 지금 필요한 DL 정도의 기능만 제공함, ObejctFactory 상속, 옵션, 스트림등 편의 기능이 많고, <br>별도의 라이브러리 필요 X, 스프링에 의존 


* implementation 'jakarta.inject:jakarta.inject-api:2.0.1' / JSR330 Provider
  * get() 메서드 하나로 기능이 매우 단순
  * 별도의 라이브러리가 필요
  * 자바 표준이므로 스프링이 아닌 다른 컨테이너에서도 사용할 수 있음. 

> 참고: 스픨ㅇ에 제공하는 메서드에 @Lookup  애노테이션을 사용하는 방법도 있지만, 이전 방법들로 충분하고, 고려해야할 내용이 많아서 생랴됐음.

> 스프링을 사용하다 보면 자바 표준과 스프링이 제공하는 기능이 겹칠때가 많이 있다. 
> 대부분 스프링이 더 다양하고 편리한 기능을 제공해주기 때문에, 특별히 다른 컨테이너를 사용할 일이 없다면, 스프링이 제공하는 기능을 사용하면 된다. 

<hr>

### 웹 스코프 
* 웹 스코프는 웹 환경에서만 동작한다.
* 웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리한다. 따라서 종료 메서드가 호출된다. 
#### 종류
* request: HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리한다.
* session: HTTP Seesion과 동일한 생성주기를 가지는 스코프 
* application: 서블릿 컨텍스틍와 동일한 생명주기를 가지는 스코프 
* websocket: 웹 소캣과 동일한 생명주기를 가지는 스코프

<hr>

### request 스코프 예제 만들기 
>request scope를 사용하지 않고 파라미터로 모든 정보를 서비스 계층에 넘긴다면, 파라미터가 많아서 지저분해진다. 
> 더 문제는 requestURL 같은 웹과 관련된 정보가 웹과 관련없는 서비스 계층까지 넘어가게 된다. 웹과 관련된 부분은 컨트롤러까지만
> 사용해야 한다. 서비스 계층은 웹 기술에 종속되지 않고, 가급적 순수하게 유지하는 것이 유지보수 관점에서 좋다. <br> 
> request scope의 MyLogger 덕분에 이런 부분을 파라미터로 넘기지 않고, MyLogger의 멤버변수에 저장해서 코드와 계층을 깔끔하게 유지할 수 있다.

<hr>

### 스코프와 Provider
* ObjectProvider 덕분에 ObjectProvider.getObject()를 호출하는 시점까지 request scope 빈의 생성을 지연할 수 있다. 
* ObjectProvider.getObject()를 호출하는 시점에는 HTTP 요청이 진행중이므로 request scope 빈의 생성이 정상 처리된다.
* ObjectProvider.getObject()를 LogDemoController, LogDemoService에서 각각 한번씩 따로 호출해도 같은 HTTP 요청이면 같은 스프링 빈이 반환된다. 

<hr>

### 스코프와 프록시
>@Component
>@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
><br>public class MyLogger {
* proxyMode = ScopedProxyMode.TARGET_CLASS 추가 
  * 적용 대상이 인터페이스면 INTERFACES
  * 적용 대상이 클래스면 TARGET_CLASS
* 이렇게 하면 MyLogger의 가짜 프록시 클래스를 만들어두고 HTTP request와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해둘 수 있다.


<strong>가짜 프록시 객체는 요청이 오면 그때 내무에서 진짜 빈을 요청하는 위임 로직이 들어있다. </strong> <br>
* 가짜 프록시 빈은 내부에 실제 MyLogger의 참조를 가지고 있다. 
* 클라이언트가 myLogger.logic()을 호출하면 사실은 가짜 프록시 객체의 메서드를 호출한 것이다. 
* 가짜 프록시 객체는 내부에 진짜 myLogger를 찾는 방법을 알고 있다. 
* 가짜 프록시 객체는 request 스코프의 진짜 mylogger.logic()을 호출한다.
* 가짜 프록시 객체는 우너본 클래스를 상속받아서 만들어졌기 때문에 이 객체를 사용하는 클라이언트 입장에서는 사실 원분인지 아닌지도 모르게, 동일하게 사용할 수 있다.(다형성)

<br>

<strong>동작 정리</string> <br>
* CGLIB라는 라이브러리로 내 클래스를 상속 받은 가짜 프록시 객체를 만들어서 주입한다.
* 이 가짜 프록시 객체는 실제 요청이 오면 그때 내부에서 실제 빈을 요청하는 위임 로직이 들어있다.
* 가짜 프록시 객체는 실제 request scope와는 관계가 없다. 그냥 가짜이고, 내부에 단순한 위임 로직만 있고, 싱글톤 처럼 동작한다.

<strong>특징 정리</string> <br>
* 프록시 객체 덕분에 클라이언트는 마치 싱글톤 빈을 사용하듯이 편리하게 request scope를 사용할 수 있다.
* 사실 Provider를 사용하든, 프록시를 사용하든 핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 지연처리한다는 점이다